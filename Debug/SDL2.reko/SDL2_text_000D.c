// SDL2_text_000D.c
// Generated by decompiling SDL2.dll
// using Reko decompiler version 0.9.1.0.

#include "SDL2_text_000D.h"

// 6CA1E7F0: Register Eq_106 fn6CA1E7F0(Stack Eq_106 dwArg04)
Eq_106 fn6CA1E7F0(Eq_106 dwArg04)
{
	Eq_106 ebx_40;
	if (fn6CA1EAEC() == 0x01)
		ebx_40 = _onexit(dwArg04);
	else
	{
		struct Eq_6005 * esp_22;
		lock();
		esp_22->t0000 = globals->t6CA4FA34;
		Eq_106 eax_28 = fn6CA1EAEC();
		esp_22->t0000 = globals->t6CA4FA30;
		Eq_106 eax_32 = fn6CA1EAEC();
		esp_22->t0000 = dwArg04;
		esp_22->ptr0008 = fp - 0x10;
		esp_22->ptr0004 = fp - 0x14;
		ebx_40 = __dllonexit(esp_22->t0000, esp_22->ptr0004, esp_22->ptr0008);
		esp_22->t0000 = eax_28;
		globals->t6CA4FA34 = fn6CA1EAF4();
		esp_22->t0000 = eax_32;
		Eq_106 eax_47 = fn6CA1EAF4();
		&esp_22->t0000.u0->dw0000 = 0x08;
		globals->t6CA4FA30 = eax_47;
		unlock();
	}
	return ebx_40;
}

// 6CA1E892: void fn6CA1E892(Stack Eq_106 dwArg04)
void fn6CA1E892(Eq_106 dwArg04)
{
	fn6CA1E7F0(dwArg04);
}

// 6CA1E8D8: void fn6CA1E8D8()
void fn6CA1E8D8()
{
	ui32 ebx_12 = globals->dw6CA1F720;
	if (ebx_12 == ~0x00)
	{
		ebx_12 = 0x00;
		while (true)
		{
			ui32 eax_19 = ebx_12 + 0x01;
			if ((&globals->dw6CA1F720)[eax_19] == 0x00)
				break;
			ebx_12 = eax_19;
		}
	}
	for (; ebx_12 != 0x00; --ebx_12)
		fn90909090();
	fn6CA1E892(1822550192);
}

// 6CA1E91D: void fn6CA1E91D()
void fn6CA1E91D()
{
	if (globals->dw6CA4F698 != 0x00)
		return;
	globals->dw6CA4F698 = 0x01;
	fn6CA1E8D8();
}

// 6CA1E934: void fn6CA1E934()
void fn6CA1E934()
{
	ui32 eax_18 = globals->dw6CA23070;
	if (eax_18 != 0xBB40E64E)
		globals->dw6CA23074 = ~eax_18;
	else
	{
		GetSystemTimeAsFileTime(fp - 44);
		Eq_28 eax_31 = GetCurrentProcessId();
		Eq_28 eax_33 = GetCurrentThreadId();
		Eq_28 eax_35 = GetTickCount();
		QueryPerformanceCounter(fp - 0x24);
		ui32 esi_48 = eax_33 ^ (eax_31 ^ ((dwLoc24 ^ 0x00) ^ dwLoc20)) ^ eax_35;
		if (esi_48 == 0xBB40E64E)
			esi_48 = ~0x44BF19B0;
		globals->dw6CA23070 = esi_48;
		globals->dw6CA23074 = ~esi_48;
	}
}

// 6CA1EA81: Register ptr32 fn6CA1EA81(Register ptr32 ecx, Register word32 edx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
ptr32 fn6CA1EA81(ptr32 ecx, word32 edx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	if (globals->dw6CA2306C != 0x02)
		globals->dw6CA2306C = 0x02;
	if (dwArg08 != 0x02)
	{
		if (dwArg08 == 0x01)
			fn6CA1EF96(ecx, edx, 0x01);
	}
	else
	{
		word32 * ebx_19;
		for (ebx_19 = globals->a6CA58028; ebx_19 != globals->a6CA58028; ++ebx_19)
		{
			<anonymous> * eax_24 = *ebx_19;
			if (eax_24 != null)
				eax_24();
		}
	}
	return ecx;
}

// 6CA1EAEC: Register word32 fn6CA1EAEC()
word32 fn6CA1EAEC()
{
	return dwArg04;
}

// 6CA1EAF4: Register word32 fn6CA1EAF4()
word32 fn6CA1EAF4()
{
	return dwArg04;
}

// 6CA1EAFC: Register Eq_421 fn6CA1EAFC(Stack Eq_182 dwArg04, Register out Eq_182 ecxOut, Register out ptr32 ebxOut, Register out ptr32 ebpOut)
Eq_421 fn6CA1EAFC(Eq_182 dwArg04, union Eq_182 & ecxOut, ptr32 & ebxOut, ptr32 & ebpOut)
{
	fputs("Mingw-w64 runtime failure:\n", iob + 0x40);
	ptr32 eax_22 = iob + 0x40;
	msvcrt.dll!vfprintf();
	abort();
	word32 ecx_52;
	Eq_421 eax_30 = fn6CA1EB3E(eax, out ecx_52);
	ecxOut.u0 = <invalid>;
	ebxOut = fp + 0x08;
	ebpOut = fp - 0x04;
	return eax_30;
}

// 6CA1EB3E: Register Eq_421 fn6CA1EB3E(Register Eq_421 eax, Register out Eq_421 ecxOut)
Eq_421 fn6CA1EB3E(Eq_421 eax, BOOL & ecxOut)
{
	int32 ebx_158 = 0x00;
	int32 esi_21 = globals->dw6CA4F9F8;
	struct Eq_6246 * edx_136 = &globals->ptr6CA4F9FC->a000C->t0000;
	while (true)
	{
		Eq_421 ecx_126;
		if (esi_21 <= ebx_158)
			break;
		BOOL ecx_138 = edx_136->dw0000;
		if (ecx_138 <= eax)
		{
			ecx_126 = (Eq_421) ((word32) ecx_138 + (edx_136->ptr0004)->dw0008);
			if (eax < ecx_126)
				goto l6CA1EC5B;
		}
		++ebx_158;
		++edx_136;
	}
	struct Eq_6251 * eax_31 = fn6CA1F130(eax, out ecx_126);
	if (eax_31 != null)
	{
		int32 ebx_42 = ebx_158 *s 0x14;
		struct Eq_6282 * eax_44 = globals->ptr6CA4F9FC + ebx_42 / 0x0C;
		eax_44->ptr0010 = eax_31;
		eax_44->dw0000 = 0x00;
		Eq_6293 eax_55 = fn6CA1F1E2() + eax_31->dw000C;
		(&globals->ptr6CA4F9FC->a000C->t0000)[ebx_42 / 0x0C] = (struct Eq_6248) eax_55;
		if (VirtualQuery(eax_55, fp - 0x38, 0x1C) == 0x00)
		{
			word32 ebx_256;
			word32 ebp_257;
			fn6CA1EAFC(0x6CA4A6F0, out ecx_126, out ebx_256, out ebp_257);
		}
		eax = dwLoc24;
		if ((dwLoc24 - 0x40 & ~0x40) != 0x00)
		{
			eax = dwLoc24 - 0x04 & ~0x04;
			if (eax != 0x00)
			{
				Eq_182 ebx_97 = globals->ptr6CA4F9FC + ebx_42 / 0x0C;
				*((word32) ebx_97 + 0x04) = dwLoc38;
				*((word32) ebx_97 + 0x08) = dwLoc2C;
				eax = VirtualProtect(dwLoc38, dwLoc2C, 0x40, ebx_97);
				if (eax == 0x00)
				{
					GetLastError();
					goto l6CA1EC50;
				}
			}
		}
l6CA1EC55:
		++globals->dw6CA4F9F8;
l6CA1EC5B:
		ecxOut = ecx_126;
		return eax;
	}
	else
	{
l6CA1EC50:
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_182 stackArg4 = (struct Eq_7645 *) <invalid>;
		word32 ebx_254;
		word32 ebp_255;
		eax = fn6CA1EAFC(stackArg4, out ecx_126, out ebx_254, out ebp_255);
		goto l6CA1EC55;
	}
}

// 6CA1EC63: Register Eq_182 fn6CA1EC63(Register Eq_182 ecx, Register Eq_182 edi, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_182 fn6CA1EC63(Eq_182 ecx, Eq_182 edi, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 ebp_144 = fp - 0x04;
	if (globals->dw6CA4F9F4 == 0x00)
	{
		globals->dw6CA4F9F4 = 0x01;
		Eq_6311 edx_149;
		uint32 eax_33 = (word32) (fn6CA1F164(out edx_149) *s 0x14) + 0x001B >> 0x04 << 0x04;
		fn6CA1F2C4(eax_33);
		globals->dw6CA4F9F8 = 0x00;
		struct Eq_6431 * esp_40 = fp - 0x4C - eax_33;
		Mem43[0x6CA4F9FC:word32] = esp_40 + 0x1F & ~0x0F;
		if (false)
		{
			struct Eq_6442 * ebx_169 = (struct Eq_6442 *) 0x6CA4C6EC;
			if (false && ((*((ui32 *) 0x6CA4C6F0) | *((ui32 *) 0x6CA4C6EC)) | *((ui32 *) 0x6CA4C6F4)) == 0x00)
				ebx_169 = (struct Eq_6442 *) 1822738168;
			if (ebx_169->dw0000 == 0x00 && ebx_169->dw0004 == 0x00)
			{
				Eq_421 eax_143;
				Eq_6469 esi_154;
				Eq_6311 eax_65 = ebx_169[0x01];
				struct Eq_6474 * ebx_132 = &ebx_169->dw0008 + 0x01;
				if (eax_65 != 0x01)
				{
					esp_40->t0004 = eax_65;
					esp_40->t0000.u0 = 0x6CA4A748;
l6CA1EDC3:
					word32 ecx_288;
					eax_143 = fn6CA1EAFC(esp_40->t0000, out ecx_288, out ebx_132, out ebp_144);
l6CA1EDC8:
					esi_154 = (word32) *((word32) edi + 0x6C940000);
					if (*((word32) edi + 0x6C940000) < 0x00)
						esi_154 |= 0xFFFF0000;
l6CA1ED53:
					Eq_6469 esi_94 = (word32) ecx + (esi_154 - *(ebp_144 - 0x30));
					Eq_6469 si_106 = (word16) esi_94;
					if (edx_149 != 0x10)
					{
						if (edx_149 != 0x20)
						{
							if (edx_149 == 0x08)
							{
								fn6CA1EB3E(eax_143, out ecx);
								*((word32) edi + 0x6C940000) = (byte) esi_94;
							}
						}
						else
						{
							fn6CA1EB3E(eax_143, out ecx);
							*((word32) edi + 0x6C940000) = esi_94;
						}
					}
					else
					{
						fn6CA1EB3E(eax_143, out ecx);
						*((word32) edi + 0x6C940000) = si_106;
					}
					++ebx_132;
				}
				if (ebx_132 < (struct Eq_6474 *) 0x6CA4C6EC)
				{
					edi = ebx_132->dw0004;
					struct Eq_6632 * edx_140 = ebx_132->dw0000;
					*(ebp_144 - 0x30) = &edx_140->t6C940000;
					eax_143 = (Eq_421) ((word32) edi + 0x6C940000);
					ecx = edx_140->t6C940000;
					edx_149 = (Eq_6311) (word32) ebx_132->b0008;
					if (edx_149 != 0x10)
					{
						if (edx_149 != 0x20)
						{
							if (edx_149 != 0x08)
							{
								esp_40->t0004 = edx_149;
								esp_40->t0000.u0 = 0x6CA4A77A;
								goto l6CA1EDC3;
							}
							esi_154 = (word32) *((word32) edi + 0x6C940000);
							if (*((word32) edi + 0x6C940000) < 0x00)
								esi_154 |= ~0xFF;
						}
						else
							esi_154 = *((word32) edi + 0x6C940000);
						goto l6CA1ED53;
					}
					goto l6CA1EDC8;
				}
			}
			else
			{
				for (; ebx_169 < (struct Eq_6442 *) 0x6CA4C6EC; ++ebx_169)
				{
					struct Eq_6487 * esi_212 = ebx_169->dw0004;
					word32 edi_215 = ebx_169->dw0000 + esi_212->dw6C940000;
					fn6CA1EB3E(&esi_212->dw6C940000, out ecx);
					esi_212->dw6C940000 = edi_215;
				}
			}
			while (*(ebp_144 - 44) < globals->dw6CA4F9F8)
			{
				struct Eq_6509 * eax_178 = globals->ptr6CA4F9FC + (*(ebp_144 - 44) *s 0x14) / 0x0C;
				Eq_28 edx_179 = eax_178->t0000;
				if (edx_179 != 0x00)
				{
					esp_40->t0008 = edx_179;
					ecx = ebp_144 - 0x1C;
					esp_40->t000C = ecx;
					esp_40->t0004 = eax_178->t0008;
					esp_40->t0000 = eax_178->t0004;
					VirtualProtect(esp_40->t0000, esp_40->t0004, esp_40->t0008, esp_40->t000C);
				}
				++*(ebp_144 - 44);
			}
		}
	}
	struct Eq_6388 * esp_201 = ebp_144 - 0x0C;
	ptr32 esi_205 = esp_201->ptr0004;
	ptr32 edi_207 = esp_201->ptr0008;
	ptr32 ebp_209 = esp_201->ptr000C;
	ebxOut = esp_201->ptr0000;
	ebpOut = ebp_209;
	esiOut = esi_205;
	ediOut = edi_207;
	return ecx;
}

// 6CA1EE5C: void fn6CA1EE5C(Register Eq_28 eax, Register ptr32 ecx, Register word32 edx)
void fn6CA1EE5C(Eq_28 eax, ptr32 ecx, word32 edx)
{
	EnterCriticalSection(&globals->t6CA4FA08);
	Eq_106 ebx_18 = globals->t6CA4FA00;
	word32 * esp_19 = fp - 0x1C;
	while (ebx_18 != 0x00)
	{
		word32 edx_63;
		Eq_28 eax_62;
		*esp_19 = (word32) *ebx_18;
		ptr32 esp_44 = esp_19 + 0x01;
		Eq_182 eax_43 = TlsGetValue(*esp_19);
		*(esp_44 - 0x04) = edx;
		esp_19 = esp_44 - 0x04;
		eax = GetLastError();
		if (eax == 0x00 && eax_43 != 0x00)
		{
			<anonymous> * eax_56 = *((word32) ebx_18 + 0x04);
			*(esp_44 - 0x04) = (union Eq_182 *) eax_43;
			eax_56();
			eax = eax_62;
			edx = edx_63;
		}
		ebx_18 = *((word32) ebx_18 + 0x08);
	}
	*esp_19 = 0x6CA4FA08;
	LeaveCriticalSection(*esp_19);
	*esp_19 = (word32) eax;
}

// 6CA1EF96: void fn6CA1EF96(Register ptr32 ecx, Register word32 edx, Stack word32 dwArg08)
void fn6CA1EF96(ptr32 ecx, word32 edx, word32 dwArg08)
{
	if (dwArg08 != 0x01)
	{
		if (dwArg08 != 0x00)
		{
			if (dwArg08 != 0x02)
			{
				if (dwArg08 == 0x03)
				{
					Eq_28 eax_63 = globals->t6CA4FA04;
					if (eax_63 != 0x00)
						fn6CA1EE5C(eax_63, ecx, edx);
				}
			}
			else
				fn6CA1F2C0();
		}
		else
		{
			Eq_28 eax_28 = globals->t6CA4FA04;
			if (eax_28 != 0x00)
				fn6CA1EE5C(eax_28, ecx, edx);
			Eq_106 eax_42 = globals->t6CA4FA00;
			if (globals->t6CA4FA04 == 0x01)
			{
				while (eax_42 != 0x00)
				{
					Eq_106 ebx_56 = *((word32) eax_42 + 0x08);
					free(eax_42);
					eax_42 = ebx_56;
				}
				&globals->t6CA4FA00.u0->dw0000 = 0x00;
				globals->t6CA4FA04 = 0x00;
				DeleteCriticalSection(&globals->t6CA4FA08);
			}
		}
	}
	else
	{
		if (globals->t6CA4FA04 == 0x00)
			InitializeCriticalSection(&globals->t6CA4FA08);
		globals->t6CA4FA04 = 0x01;
	}
}

// 6CA1F054: Register uint32 fn6CA1F054(Stack (ptr32 Eq_6826) dwArg04)
uint32 fn6CA1F054(struct Eq_6826 * dwArg04)
{
	uint32 eax_30 = 0x00;
	if (dwArg04->w0000 == 23117)
	{
		struct Eq_6834 * edx_12 = dwArg04 + dwArg04->dw003C / 0x0040;
		if (edx_12->dw0000 == 0x4550)
			eax_30 = (uint32) (uint8) (edx_12->w0018 == 0x010B);
	}
	return eax_30;
}

// 6CA1F07B: Register (ptr32 Eq_6851) fn6CA1F07B(Stack (ptr32 Eq_6852) dwArg04, Stack Eq_6853 dwArg08, Register out Eq_6853 ecxOut)
struct Eq_6851 * fn6CA1F07B(struct Eq_6852 * dwArg04, Eq_6853 dwArg08, union Eq_6853 & ecxOut)
{
	struct Eq_6855 * edx_17 = dwArg04 + dwArg04->dw003C / 0x0040;
	up32 ebx_16;
	up32 esi_20 = (word32) edx_17->w0006;
	struct Eq_6851 * eax_21 = &edx_17->w0014 + 0x02 + (word32) edx_17->w0014 / 22;
	for (ebx_16 = 0x00; esi_20 > ebx_16; ++ebx_16)
	{
		Eq_6853 edx_31 = eax_21->dw000C;
		if (edx_31 <= dwArg08 && (word32) edx_31 + eax_21->dw0008 > dwArg08)
			goto l6CA1F0B1;
		++eax_21;
	}
	eax_21 = null;
l6CA1F0B1:
	ecxOut = dwArg08;
	return eax_21;
}

// 6CA1F130: Register word32 fn6CA1F130(Stack Eq_421 dwArg04, Register out ptr32 ecxOut)
word32 fn6CA1F130(Eq_421 dwArg04, ptr32 & ecxOut)
{
	word32 eax_18 = 0x00;
	if (fn6CA1F054(&globals->t6C940000) != 0x00)
		eax_18 = fn6CA1F07B(&globals->t6C940000, dwArg04 - 0x6C940000, out ecx);
	ecxOut = ecx;
	return eax_18;
}

// 6CA1F164: Register ptr32 fn6CA1F164(Register out ptr32 edxOut)
ptr32 fn6CA1F164(ptr32 & edxOut)
{
	ptr32 edx_17 = 0x00;
	if (fn6CA1F054(&globals->t6C940000) != 0x00)
		edx_17 = (word32) globals->ptr6C94003C->w6C940006;
	edxOut = edx_17;
	return edx_17;
}

// 6CA1F1E2: Register ptr32 fn6CA1F1E2()
ptr32 fn6CA1F1E2()
{
	ptr32 eax_23 = 0x6C940000;
	if (fn6CA1F054(&globals->t6C940000) == 0x00)
		eax_23 = 0x00;
	return eax_23;
}

// 6CA1F2C0: void fn6CA1F2C0()
void fn6CA1F2C0()
{
	__fninit();
}

// 6CA1F2C4: void fn6CA1F2C4(Register uint32 eax)
void fn6CA1F2C4(uint32 eax)
{
	struct Eq_6934 * ecx_11 = fp + 0x04;
	if (eax >= 0x1000)
	{
		do
		{
			ecx_11 -= 0x1000;
			ecx_11->dw0000 = ecx_11->dw0000;
			eax -= 0x1000;
		} while (eax > 0x1000);
	}
	word32 * ecx_25 = ecx_11 - eax;
	*ecx_25 = *ecx_25;
}

// 6CA1F600: Register word32 fn6CA1F600()
word32 fn6CA1F600()
{
	return 0x01;
}

// 6CA1F608: Register word32 fn6CA1F608()
word32 fn6CA1F608()
{
	return 0x01;
}

